---
title: "parallel - homework & notes"
author: 
  徐红柚
  19377031
date: "`r Sys.Date()`"
output: 
  prettydoc::html_pretty:
    theme: HPSTR
    helight: github
editor_options: 
  chunk_output_type: console
---

# [Python线程学习](https://www.runoob.com/python3/python3-multithreading.html#:~:text=Python3%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%201%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Python%E7%BA%BF%E7%A8%8B%20Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%94%A8%E7%B1%BB%E6%9D%A5%E5%8C%85%E8%A3%85%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E3%80%82%20%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%9A%E8%B0%83%E7%94%A8%20_thread%20%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84start_new_thread,4%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20%E5%A6%82%E6%9E%9C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E5%90%8C%E5%AF%B9%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%88%99%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%96%99%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%B9%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E3%80%82%20...%205%20%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88%20Queue%EF%BC%89%20)

Python3 线程中常用的两个模块为： - \_thread （thread已被废弃，为了兼容性thread重命名为_thread） - threading（推荐）

Python中使用线程有两种方式：函数或者用类来包装线程对象。

## \_thread

函数式：调用 \_thread 模块中的start_new_thread()函数来产生新线程。语法如下:

`_thread.start_new_thread ( function, args[, kwargs] )`

-   function 线程函数

-   args 传递给线程函数的参数,他必须是个tuple类型

-   kwargs 可选参数

## EXAMPLE 1 \_thread

```{r,echo=TRUE,eval=FALSE}
import _thread
import time

# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count < 5:
      time.sleep(delay)
      count += 1
      print ("%s: %s" % ( threadName, time.ctime(time.time()) ))

# 创建两个线程
try:
   _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
   _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
   print ("Error: 无法启动线程")

while 1:
   pass
```

## threading

\_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。

threading 模块除了包含 \_thread 模块中的所有方法外，还提供的其他方法：

-   `threading.currentThread()`: 返回当前的线程变量。
-   `threading.enumerate()`: 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
-   `threading.activeCount()`: 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。

### Thread类

-   `run()`: 用以表示线程活动的方法。
-   `start()`:启动线程活动。
-   `join([time])`: 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
-   `isAlive()`: 返回线程是否活动的。
-   `getName()`: 返回线程名。
-   `setName()`: 设置线程名。

## EXAMPLE 2 threading

我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：

```{r,echo=TRUE,eval=FALSE}
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print ("开始线程：" + self.name)
        print_time(self.name, self.delay, 5)
        print ("退出线程：" + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print ("退出主线程")
```

## 线程同步

如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。

使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：

多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。

考虑这样一种情况：一个列表里所有元素都是0，线程"set"从后向前把所有元素改成1，而线程"print"负责从前往后读取列表并打印。

那么，可能线程"set"开始改的时候，线程"print"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。

锁有两种状态------锁定和未锁定。每当一个线程比如"set"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如"print"获得锁定了，那么就让线程"set"暂停，也就是同步阻塞；等到线程"print"访问完毕，释放锁以后，再让线程"set"继续。

经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。

## EXAMPLE 3 线程同步

```{r,echo=TRUE,eval=FALSE}
import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print ("开启线程： " + self.name)
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.delay, 3)
        # 释放锁，开启下一个线程
        threadLock.release()

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print ("退出主线程")
```

## 线程优先级队列（Queue）

Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。

这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。

Queue 模块中的常用方法:

-   `Queue.qsize()` 返回队列的大小
-   `Queue.empty()` 如果队列为空，返回True,反之False
-   `Queue.full()` 如果队列满了，返回True,反之False
-   `Queue.full` 与 maxsize 大小对应
-   `Queue.get([block[, timeout]])` 获取队列，timeout等待时间
-   `Queue.get_nowait()` 相当Queue.get(False)
-   `Queue.put(item)` 写入队列，timeout等待时间
-   `Queue.put_nowait(item)` 相当Queue.put(item, False)
-   `Queue.task_done()` 在完成一项工作之后，`Queue.task_done()`函数向任务已经完成的队列发送一个信号 `Queue.join()` 实际上意味着等到队列为空，再执行别的操作

## EXAMPLE 4 Queue

```{r,echo=TRUE,eval=FALSE}
import queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print ("开启线程：" + self.name)
        process_data(self.name, self.q)
        print ("退出线程：" + self.name)

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print ("%s processing %s" % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)

threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1

# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# 等待队列清空
while not workQueue.empty():
    pass

# 通知线程是时候退出
exitFlag = 1

# 等待所有线程完成
for t in threads:
    t.join()
print ("退出主线程")

```

# LAB - Homework

- Think about a slow piece of code you have ever written for either your past assignments or projects.

- Parallelize it in Python.

```{r,echo=TRUE,eval=FALSE}
from threading import Thread,currentThread
import time

def task(name):
    time.sleep(2)
    print('%s print name: %s' %(currentThread().name,name))

class Task(Thread):
    def __init__(self,name):
        super().__init__()
        self._name=name
    
    def run(self):
        time.sleep(2)
        print('%s print name: %s' % (currentThread().name,self._name))

if __name__ == '__main__':
    n=100
    var='test'
    t=Thread(target=task,args=('thread_task_func',))
    t.start()
    t.join()

    t=Task('thread_task_class')
    t.start()
    t.join()
    
    print('main')
```

Result:

```{r,echo=TRUE,eval=FALSE}
Thread-19 print name: thread_task_func
thread_task_class print name: thread_task_class
main
```